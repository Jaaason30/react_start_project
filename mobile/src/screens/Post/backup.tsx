// src/screens/Post/PostDetailScreen.tsx

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  Dimensions,
  StatusBar,
  Image,
  TextInput,
  Modal,
  KeyboardAvoidingView,
  ActivityIndicator,
  RefreshControl,
  Platform,
  Alert,
} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import FastImage from 'react-native-fast-image';
import {
  useRoute,
  useNavigation,
  useFocusEffect,
} from '@react-navigation/native';
import type { RouteProp } from '@react-navigation/native';
import { styles } from '../../theme/PostDetailScreen.styles';
import { useUserProfile } from '../../contexts/UserProfileContext';

// ‰ΩøÁî® apiClient Âíå API_ENDPOINTS
import { apiClient } from '../../services/apiClient';
import { API_ENDPOINTS, BASE_URL } from '../../constants/api';

const { width } = Dimensions.get('window');

/* ---------- Ë∑ØÁî±Á±ªÂûã ---------- */
type RootStackParamList = {
  PostDetail: { post: { uuid: string } };
};
type PostDetailRouteProp = RouteProp<RootStackParamList, 'PostDetail'>;

/* ---------- ËØÑËÆ∫ÂíåÂ∏ñÂ≠êÁöÑÁ±ªÂûã ---------- */
type CommentType = {
  id: string;
  authorUuid: string;
  user: string;
  avatar: string;
  content: string;
  time: string;
  likes: number;
  liked: boolean;
  parentCommentUuid?: string;
  replyToUser?: { uuid: string; nickname: string };
  replyCount: number;
  replies?: CommentType[];
};

type SortType = 'ÊúÄÊñ∞' | 'ÊúÄÁÉ≠';

type PostType = {
  uuid: string;
  title: string;
  content: string;
  images: string[];
  author: string;
  authorAvatar: string;
  authorUuid: string;
  likeCount: number;
  collectCount: number;
  commentCount: number;
  likedByCurrentUser: boolean;
  collectedByCurrentUser: boolean;
  followedByCurrentUser: boolean;
};
export default function PostDetailScreen() {
  const navigation = useNavigation();
  const route = useRoute<PostDetailRouteProp>();
  const { post: initialPost } = route.params;
  const { profileData, refreshProfile, avatarVersion } = useUserProfile();

  // ------- refs & state -------
  const listRef = useRef<FlatList<CommentType>>(null);
  const [commentY, setCommentY] = useState(0);
  const [post, setPost] = useState<PostType | null>(null);
  const [imageDimensions, setImageDimensions] = useState<
    { width: number; height: number }[]
  >([]);
  const [loading, setLoading] = useState(true);

  const [comments, setComments] = useState<CommentType[]>([]);
  const [commentText, setCommentText] = useState('');
  const [showCommentModal, setShowCommentModal] = useState(false);
  const [activeSort, setActiveSort] = useState<SortType>('ÊúÄÊñ∞');
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const [isLiked, setIsLiked] = useState(false);
  const [isCollected, setIsCollected] = useState(false);
  const [isFollowing, setIsFollowing] = useState(false);

  const [replyingTo, setReplyingTo] = useState<{
    commentId: string;
    userName: string;
    parentCommentUuid?: string;
    replyToUserUuid?: string;
  } | null>(null);
  const [showReplies, setShowReplies] = useState<Set<string>>(new Set());
  const [loadingReplies, setLoadingReplies] = useState<Set<string>>(
    new Set()
  );

  // ------- Â∑•ÂÖ∑ÔºöÊãºÊé•ËµÑÊ∫êÁöÑ URL -------
const patchUrl = (url?: string) => {
  if (!url) return null;
  if (url.startsWith('http')) return url;
  const full = `${BASE_URL}${url}`;
  //console.log('[patchUrl] input:', url, '=>', full);
  return full;
};

const patchProfileUrl = (url?: string) => {
  const u = patchUrl(url);
  const finalUrl = u && avatarVersion ? `${u}?v=${avatarVersion}` : u || undefined;
  //console.log('[patchProfileUrl] raw:', url, 'version:', avatarVersion, '=>', finalUrl);
  return finalUrl;
};
  /* ========== Âà†Èô§Â∏ñÂ≠ê (JWT) ========== */
  const handleDeletePost = () => {
    Alert.alert('Á°ÆËÆ§Âà†Èô§', 'Âà†Èô§ÂêéÊó†Ê≥ïÊÅ¢Â§çÔºåÁ°ÆÂÆöÂà†Èô§Ê≠§Â∏ñÂ≠êÂêóÔºü', [
      { text: 'ÂèñÊ∂à', style: 'cancel' },
      {
        text: 'Âà†Èô§',
        style: 'destructive',
        onPress: async () => {
          try {
            await apiClient.delete(
              `${API_ENDPOINTS.POST_DETAIL}/${post!.uuid}`
            );
            Alert.alert('Â∑≤Âà†Èô§', 'Â∏ñÂ≠êÂ∑≤Âà†Èô§');
            navigation.goBack();
          } catch (err) {
            console.error('[‚ùå deletePost]', err);
            Alert.alert('Âà†Èô§Â§±Ë¥•', 'ËØ∑Á®çÂêéÈáçËØï');
          }
        },
      },
    ]);
  };

  /* ========== 1) Ëé∑ÂèñÂ∏ñÂ≠êËØ¶ÊÉÖ (JWT) ========== */
  const fetchPostDetail = async () => {
    try {
      const { data } = await apiClient.get<any>(
        `${API_ENDPOINTS.POST_DETAIL}/${initialPost.uuid}`
      );

      const avatarUrl =
        patchProfileUrl(data.author?.profilePictureUrl) ||
        'https://via.placeholder.com/200x200.png?text=No+Avatar';
        console.log('[fetchPostDetail] author avatar:', avatarUrl);


      const processedImages = (data.images || []).map(
        (img: any) => patchUrl(img.url) || img.url
      );

      const newPost: PostType = {
        uuid: data.uuid,
        title: data.title,
        content: data.content,
        images: processedImages,
        author: data.author?.nickname || 'Êú™Áü•Áî®Êà∑',
        authorAvatar: avatarUrl,
        authorUuid: data.author?.uuid,
        likeCount: data.likeCount ?? 0,
        collectCount: data.collectCount ?? 0,
        commentCount: data.commentCount ?? 0,
        likedByCurrentUser: !!data.likedByCurrentUser,
        collectedByCurrentUser: !!data.collectedByCurrentUser,
        followedByCurrentUser: data.followedByCurrentUser ?? false,
      };

      setPost(newPost);
      setIsLiked(!!data.likedByCurrentUser);
      setIsCollected(!!data.collectedByCurrentUser);
      setIsFollowing(newPost.followedByCurrentUser);
    } catch (err) {
      console.error('[‚ùå fetchPostDetail]', err);
    }
  };

  /* ========== 2) Ëé∑ÂèñËØÑËÆ∫ (JWT) ========== */
  const fetchComments = async (pageNumber = 0) => {
    //console.log(`[fetchComments] page: ${pageNumber}, sort: ${activeSort}`);
    try {
      const sortParam = activeSort === 'ÊúÄÊñ∞' ? 'LATEST' : 'HOT';

      const { data } = await apiClient.get<any>(
        `${API_ENDPOINTS.POST_COMMENTS.replace(':uuid', initialPost.uuid)}` +
          `?sortType=${sortParam}` +
          `&page=${pageNumber}&size=10&loadReplies=true`
      );

      const newComments: CommentType[] = (data.content || []).map((c: any) => {
        const processedReplies: CommentType[] = (c.replies || []).map((r: any) => ({
          id: r.uuid,
          authorUuid: r.author.uuid,
          user: r.author.nickname,
          avatar:
            patchProfileUrl(r.author.profilePictureUrl) ||
            'https://via.placeholder.com/100x100.png?text=No+Avatar',
          content: r.content,
          time: new Date(r.createdAt).toLocaleString(),
          likes: r.likeCount ?? 0,
          liked: !!r.likedByCurrentUser,
          parentCommentUuid: r.parentCommentUuid,
          replyToUser: r.replyToUser,
          replyCount: 0,
        }));

        return {
          id: c.uuid,
          authorUuid: c.author.uuid,
          user: c.author.nickname,
          avatar:
            patchProfileUrl(c.author.profilePictureUrl) ||
            'https://via.placeholder.com/100x100.png?text=No+Avatar',
          content: c.content,
          time: new Date(c.createdAt).toLocaleString(),
          likes: c.likeCount ?? 0,
          liked: !!c.likedByCurrentUser,
          parentCommentUuid: c.parentCommentUuid,
          replyToUser: c.replyToUser,
          replyCount: c.replyCount || 0,
          replies: processedReplies,
        };
      });

      setComments(prev =>
        pageNumber === 0 ? newComments : [...prev, ...newComments]
      );
      setHasMore(!data.last);
    } catch (err) {
      console.error('[‚ùå fetchComments]', err);
    }
  };

  /* ========== 3) Âä†ËΩΩËØÑËÆ∫ÁöÑÂõûÂ§ç (JWT) ========== */

const fetchReplies = async (commentId: string) => {
  console.log(`[üì• fetchReplies] ËØ∑Ê±ÇÂä†ËΩΩÂõûÂ§ç‰∏≠ (commentId: ${commentId})`);
  setLoadingReplies(prev => new Set(prev).add(commentId));

  try {
    const url = `${API_ENDPOINTS.COMMENT_REPLIES.replace(':id', commentId)}?page=0&size=20`;
    const { data } = await apiClient.get<any>(url);

    const replies: CommentType[] = (data.content || [])
      .filter(r => r != null)
      .map(r => ({
        id: r.uuid,
        authorUuid: r.author.uuid,
        user: r.author.nickname,
        avatar: patchProfileUrl(r.author.profilePictureUrl) ||
                'https://via.placeholder.com/100x100.png?text=No+Avatar',
        content: r.content,
        time: new Date(r.createdAt).toLocaleString(),
        likes: r.likeCount,
        liked: !!r.likedByCurrentUser,
        parentCommentUuid: r.parentCommentUuid,
        replyToUser: r.replyToUser,
        replyCount: 0,
      }));

    console.log(`[‚úÖ fetchReplies] Ëé∑ÂèñÂà∞ ${replies.length} Êù°ÂõûÂ§çÔºåÊõ¥Êñ∞ËØÑËÆ∫`);

    setComments(prev =>
      prev.map(c =>
        c.id === commentId ? { ...c, replies } : c
      )
    );

    setShowReplies(prev => {
      const newSet = new Set(prev);
      newSet.add(commentId);
      return newSet;
    });
  } catch (err: any) {
    console.error(`[‚ùå fetchReplies] Âä†ËΩΩÂ§±Ë¥• - commentId: ${commentId}`);
    if (err.response) {
      console.error('ÂìçÂ∫îÁä∂ÊÄÅ:', err.response.status);
      console.error('ÂìçÂ∫îÊï∞ÊçÆ:', err.response.data);
    } else {
      console.error('ÈîôËØØ‰ø°ÊÅØ:', err.message);
    }
  } finally {
    setLoadingReplies(prev => {
      const newSet = new Set(prev);
      newSet.delete(commentId);
      return newSet;
    });
    console.log(`[üèÅ fetchReplies] Â§ÑÁêÜÂÆåÊàê - commentId: ${commentId}`);
  }
};

  // ÂºÄÂßãÂõûÂ§çËØÑËÆ∫
  const handleReply = (comment: CommentType) => {
    setReplyingTo({
      commentId: comment.id,
      userName: comment.user,
      parentCommentUuid: comment.parentCommentUuid || comment.id,
      replyToUserUuid: comment.authorUuid,
    });
    setShowCommentModal(true);
  };

  /* ========== 4) ÂÖ≥Ê≥® / ÂèñÊ∂àÂÖ≥Ê≥® (JWT) ========== */
  const toggleFollow = async () => {
    if (!post) return;
    try {
      if (isFollowing) {
        await apiClient.delete(
          `${API_ENDPOINTS.USER_FOLLOW}?targetUuid=${post.authorUuid}`
        );
      } else {
        await apiClient.post(
          `${API_ENDPOINTS.USER_FOLLOW}?targetUuid=${post.authorUuid}`
        );
      }
      setIsFollowing(prev => !prev);
    } catch (err) {
      console.error('[‚ùå toggleFollow]', err);
      Alert.alert(isFollowing ? 'ÂèñÊ∂àÂÖ≥Ê≥®Â§±Ë¥•' : 'ÂÖ≥Ê≥®Â§±Ë¥•');
    }
  };

  /* ========== 5) ÁÇπËµû / Êî∂Ëóè (JWT) ========== */
const toggleReaction = async (type: 'LIKE' | 'COLLECT') => {
  try {
    const response = await apiClient.post<any>(
      `${API_ENDPOINTS.POST_REACTIONS.replace(':uuid', initialPost.uuid)}`,
      { type }
    );
    console.log(`[toggleReaction] Full response:`, response);
    console.log(`[toggleReaction] Response status:`, response.status);
    console.log(`[toggleReaction] Response data:`, response.data);
    // Ê∑ªÂä†Á©∫ÂÄºÊ£ÄÊü•
    if (!response.data) {
      console.error(`[‚ùå toggleReaction ${type}] Response data is null`);
      // ÂèØ‰ª•ÈÄâÊã©ÊòæÁ§∫ÈîôËØØÊèêÁ§∫
      Alert.alert('Êìç‰ΩúÂ§±Ë¥•', 'ÊúçÂä°Âô®ÂìçÂ∫îÂºÇÂ∏∏ÔºåËØ∑Á®çÂêéÈáçËØï');
      return;
    } 
    
    const { data } = response;
    
    // Êõ¥Êñ∞Â∏ñÂ≠êÁä∂ÊÄÅ 
    setPost(prev =>
      prev
        ? {
            ...prev,
            likeCount: data.likeCount ?? prev.likeCount,
            collectCount: data.collectCount ?? prev.collectCount,
            commentCount: data.commentCount ?? prev.commentCount,
            likedByCurrentUser: data.likedByCurrentUser ?? false,
            collectedByCurrentUser: data.collectedByCurrentUser ?? false,
          }
        : prev
    );
    
    // Êõ¥Êñ∞Áã¨Á´ãÁöÑÁä∂ÊÄÅ
    setIsLiked(data.likedByCurrentUser ?? false);
    setIsCollected(data.collectedByCurrentUser ?? false);
    
  } catch (err) {
    console.error(`[‚ùå toggleReaction ${type}]`, err);
    Alert.alert('Êìç‰ΩúÂ§±Ë¥•', 'ÁΩëÁªúÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï');
  }
};
  /* ========== 6) Âà†Èô§ËØÑËÆ∫ (JWT) ========== */
  const handleDeleteComment = (id: string) => {
    Alert.alert('Á°ÆËÆ§Âà†Èô§', 'Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËØÑËÆ∫ÂêóÔºü', [
      { text: 'ÂèñÊ∂à', style: 'cancel' },
      {
        text: 'Âà†Èô§',
        style: 'destructive',
        onPress: async () => {
          try {
            await apiClient.delete(
              `${API_ENDPOINTS.COMMENT_DELETE.replace(':id', id)}`
            );
            setComments(prev => prev.filter(c => c.id !== id));
            setPost(prev =>
              prev ? { ...prev, commentCount: prev.commentCount - 1 } : prev
            );
          } catch (err) {
            console.error('[‚ùå deleteComment]', err);
          }
        },
      },
    ]);
  };

  /* ========== 7) ÂèëÂ∏ÉËØÑËÆ∫ / ÂõûÂ§ç (JWT) ========== */
  const submitComment = async () => {
    if (!commentText.trim()) return;
    const payload = {
      content: commentText.trim(),
      parentCommentUuid: replyingTo?.parentCommentUuid,
      replyToUserUuid: replyingTo?.replyToUserUuid,
    };
    try {
      const { data } = await apiClient.post<any>(
        `${API_ENDPOINTS.POST_COMMENTS.replace(':uuid', initialPost.uuid)}`,
        payload
      );

      const newComment: CommentType = {
        id: data.uuid,
        authorUuid: data.author.uuid,
        user: data.author.nickname,
        avatar: data.author.profilePictureUrl
          ? `${BASE_URL}${data.author.profilePictureUrl}`
          : 'https://via.placeholder.com/100x100.png?text=No+Avatar',
        content: data.content,
        time: new Date(data.createdAt).toLocaleString(),
        likes: 0,
        liked: false,
        replyCount: 0,
        parentCommentUuid: data.parentCommentUuid,
        replyToUser: data.replyToUser,
      };

      if (replyingTo) {
        setComments(prev =>
          prev.map(c =>
            c.id === replyingTo.parentCommentUuid
              ? {
                  ...c,
                  replyCount: c.replyCount + 1,
                  replies: [...(c.replies || []), newComment],
                }
              : c
          )
        );
        setShowReplies(prev => new Set(prev).add(replyingTo.parentCommentUuid!));
      } else {
        setComments(prev => [newComment, ...prev]);
      }

      setCommentText('');
      setReplyingTo(null);
      setShowCommentModal(false);
      setPost(prev =>
        prev ? { ...prev, commentCount: prev.commentCount + 1 } : prev
      );
    } catch (err) {
      console.error('[‚ùå submitComment]', err);
    }
  };
  /* ========== 8) ËÆ°ÁÆóÂõæÁâáÂ∞∫ÂØ∏ ========== */
  useEffect(() => {
    if (!post?.images?.length) return;
    (async () => {
      const dims = await Promise.all(
        post.images.map(
          url =>
            new Promise<{ width: number; height: number }>(resolve => {
              Image.getSize(
                url,
                (w, h) => resolve({ width: w, height: h }),
                () => resolve({ width, height: width })
              );
            })
        )
      );
      setImageDimensions(dims);
    })();
  }, [post?.images]);

  /* ========== 9) ÂàùÊ¨°Âä†ËΩΩ & ‰æùËµñÂèòÂåñ ========== */
  useEffect(() => {
    const loadInitial = async () => {
      setLoading(true);
      await fetchPostDetail();
      setLoading(false);
    };
    loadInitial();
  }, [initialPost.uuid]);

  useEffect(() => {
    fetchComments(0);
    setPage(0);
  }, [initialPost.uuid, activeSort]);

  useEffect(() => {
    if (post?.authorUuid === profileData?.uuid) {
      fetchPostDetail();
    }
  }, [profileData?.profilePictureUrl]);

  useFocusEffect(
    React.useCallback(() => {
      if (post?.authorUuid === profileData?.uuid) {
        fetchPostDetail();
      }
      return () => {};
    }, [post?.authorUuid, profileData?.uuid])
  );

  const onRefresh = async () => {
    setRefreshing(true);
    await refreshProfile();
    await fetchPostDetail();
    await fetchComments(0);
    setRefreshing(false);
  };

  const loadMore = () => {
    if (!hasMore) return;
    const next = page + 1;
    setPage(next);
    fetchComments(next);
  };

  const scrollToComments = () => {
    listRef.current?.scrollToOffset({
      offset: commentY,
      animated: true,
    });
  };
  /* ========== Ê∏≤Êüì ========== */
  if (loading || !post) {
    return (
      <View
        style={[
          styles.container,
          { justifyContent: 'center', alignItems: 'center' },
        ]}
      >
        <ActivityIndicator size="large" color="#d81e06" />
        <Text style={{ marginTop: 12, color: '#666' }}>
          Âä†ËΩΩÂ∏ñÂ≠êËØ¶ÊÉÖ‰∏≠...
        </Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar barStyle="dark-content" />
      <FlatList
        ref={listRef}
        ListHeaderComponent={
          <>
            {/* È°∂ÈÉ®ÂØºËà™ + ‰ΩúËÄÖ‰ø°ÊÅØ */}
            <View style={styles.topBar}>
              <TouchableOpacity onPress={() => navigation.goBack()}>
                <Ionicons name="chevron-back" size={24} />
              </TouchableOpacity>
              {profileData?.uuid === post.authorUuid && (
                <TouchableOpacity
                  onPress={handleDeletePost}
                  style={{ marginLeft: 16 }}
                >
                  <Ionicons
                    name="trash-outline"
                    size={24}
                    color="#d81e06"
                  />
                </TouchableOpacity>
              )}
              <FastImage
                source={{
                  uri: post.authorAvatar,
                  headers: { 'Cache-Control': 'no-cache' },
                  priority: FastImage.priority.high,
                }}
                style={styles.avatar}
                resizeMode={FastImage.resizeMode.cover}
              />
              <Text style={styles.authorName}>{post.author}</Text>
              {profileData?.uuid !== post.authorUuid && (
                <TouchableOpacity
                  style={
                    isFollowing
                      ? styles.unfollowBtn
                      : styles.followBtn
                  }
                  onPress={toggleFollow}
                >
                  <Text
                    style={
                      isFollowing
                        ? styles.unfollowText
                        : styles.followText
                    }
                  >
                    {isFollowing ? 'ÂèñÊ∂àÂÖ≥Ê≥®' : 'ÂÖ≥Ê≥®'}
                  </Text>
                </TouchableOpacity>
              )}
            </View>

            {/* ÂõæÁâáËΩÆÊí≠ */}
            <FlatList
              horizontal
              data={post.images}
              keyExtractor={(_, idx) => String(idx)}
              pagingEnabled
              showsHorizontalScrollIndicator={false}
              renderItem={({ item, index }) => (
                <FastImage
                  source={{ uri: item }}
                  style={[
                    styles.image,
                    {
                      height:
                        (imageDimensions[index]?.height /
                          imageDimensions[index]?.width) *
                        width,
                    },
                  ]}
                  resizeMode={FastImage.resizeMode.contain}
                />
              )}
            />

            {/* Ê†áÈ¢ò & Ê≠£Êñá */}
            <View style={styles.contentContainer}>
              <Text style={styles.title}>{post.title}</Text>
              <Text style={styles.body}>
                {post.content || 'ÊöÇÊó†ÂÜÖÂÆπ'}
              </Text>
            </View>

            {/* ËØÑËÆ∫Âå∫Â§¥ÈÉ® */}
            <View
              onLayout={e =>
                setCommentY(e.nativeEvent.layout.y)
              }
              style={styles.commentHeader}
            >
              <Text style={styles.commentHeaderText}>
                ÂÖ®ÈÉ®ËØÑËÆ∫
              </Text>
              <View style={styles.commentTabs}>
                {(['ÊúÄÊñ∞', 'ÊúÄÁÉ≠'] as SortType[]).map(t => (
                  <TouchableOpacity
                    key={t}
                    onPress={() => setActiveSort(t)}
                    style={[
                      styles.commentTab,
                      activeSort === t &&
                        styles.activeCommentTab,
                    ]}
                  >
                    <Text
                      style={[
                        styles.commentTabText,
                        activeSort === t &&
                          styles.activeCommentTabText,
                      ]}
                    >
                      {t}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
          </>
        }data={comments}
        keyExtractor={item => item.id}
        renderItem={({ item }) => (
          <View style={styles.commentItem}>
            <FastImage
              source={{
                uri: item.avatar,
                headers: { 'Cache-Control': 'no-cache' },
                priority: FastImage.priority.normal,
              }}
                //onLoad={e => console.log('[AuthorAvatar onLoad]', post.authorAvatar)}
              style={styles.commentAvatar}
              resizeMode={FastImage.resizeMode.cover}
            />
            <View style={{ flex: 1, marginLeft: 8 }}>
              <View style={styles.commentTopRow}>
                <Text style={styles.commentUser}>{item.user}</Text>
                <View style={styles.commentActions}>
                  <TouchableOpacity
                    style={styles.likeButton}
                    onPress={async () => {
                      try {
                        const { data: upd } = await apiClient.post<any>(
                          `${API_ENDPOINTS.COMMENT_LIKES.replace(':id', item.id)}`
                        );
                        setComments(prev =>
                          prev.map(c =>
                            c.id === item.id
                              ? {
                                  ...c,
                                  likes: upd.likeCount,
                                  liked: upd.likedByCurrentUser,
                                }
                              : c
                          )
                        );
                      } catch (e) {
                        console.error(e);
                      }
                    }}
                  >
                    <Ionicons
                      name={item.liked ? 'heart' : 'heart-outline'}
                      size={16}
                      color={item.liked ? '#f33' : '#888'}
                    />
                    <Text
                      style={[
                        styles.commentLikes,
                        item.liked && { color: '#f33' },
                      ]}
                    >
                      {item.likes}
                    </Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => handleReply(item)}
                    style={{ marginLeft: 16 }}
                  >
                    <Ionicons
                      name="chatbubble-outline"
                      size={16}
                      color="#888"
                    />
                  </TouchableOpacity>

                  {profileData?.uuid === item.authorUuid && (
                    <TouchableOpacity
                      onPress={() => handleDeleteComment(item.id)}
                      style={{ marginLeft: 16 }}
                    >
                      <Ionicons
                        name="trash-outline"
                        size={16}
                        color="#888"
                      />
                    </TouchableOpacity>
                  )}
                </View>
              </View>

              {item.replyToUser && (
                <Text style={styles.replyToText}>
                  ÂõûÂ§ç @{item.replyToUser.nickname}
                </Text>
              )}

              <Text style={styles.commentContent}>
                {item.content}
              </Text>
              <Text style={styles.commentTime}>{item.time}</Text>

{item.replyCount > 0 && (
                <TouchableOpacity
                  onPress={() => {
                    if (showReplies.has(item.id)) {
                      setShowReplies(prev => {
                        const newSet = new Set(prev);
                        newSet.delete(item.id);
                        return newSet;
                      });
                    } else {
                      fetchReplies(item.id);
                    }
                  }}
                  style={styles.viewRepliesButton}
                >
                  <Text style={styles.viewRepliesText}>
                    {loadingReplies.has(item.id)
                      ? 'Âä†ËΩΩ‰∏≠...'
                      : showReplies.has(item.id)
                      ? 'Êî∂Ëµ∑ÂõûÂ§ç'
                      : `Êü•Áúã ${item.replyCount} Êù°ÂõûÂ§ç`}
                  </Text>
                </TouchableOpacity>
              )}
            </View>

            {(() => {
            const shouldShow = showReplies.has(item.id);
            const hasReplies = item.replies && item.replies.length > 0;
            return shouldShow && hasReplies &&
              item.replies.map((reply, index) => {
                console.log(`[üîÅ ÂõûÂ§ç ${index + 1}] ID: ${reply.id}ÔºåÂÜÖÂÆπ: ${reply.content}`);
                
                return (
                  <View
                    key={reply.id}
                    style={[styles.commentItem, styles.replyItem]}
                  >
                    <FastImage
                      source={{
                        uri: reply.avatar,
                        headers: { 'Cache-Control': 'no-cache' },
                        priority: FastImage.priority.normal,
                      }}
                      //onLoad={e => console.log('[CommentAvatar onLoad]', item.id, item.avatar)}
                      style={styles.commentAvatar}
                      resizeMode={FastImage.resizeMode.cover}
                    />
                    <View style={{ flex: 1, marginLeft: 8 }}>
                      <View style={styles.commentTopRow}>
                        <Text style={styles.commentUser}>
                          {reply.user}
                        </Text>
                        {reply.replyToUser && (
                          <Text style={styles.replyToInline}>
                            ÂõûÂ§ç @{reply.replyToUser.nickname}
                          </Text>
                        )}
                        <View style={styles.commentActions}>
                          <TouchableOpacity
                            style={styles.likeButton}
                            onPress={async () => {
                              //console.log(`[ÁÇπËµûÂõûÂ§ç] ÂõûÂ§çID: ${reply.id}`);
                              try {
                                const { data: upd } = await apiClient.post<any>(
                                  `${API_ENDPOINTS.COMMENT_LIKES.replace(':id', reply.id)}`
                                );
                                //console.log(`[ÁÇπËµûÂõûÂ§ç] ÁÇπËµûÁªìÊûú:`, upd);
                                setComments(prev =>
                                  prev.map(c => ({
                                    ...c,
                                    replies: c.replies?.map(r =>
                                      r.id === reply.id
                                        ? {
                                            ...r,
                                            likes: upd.likeCount,
                                            liked: upd.likedByCurrentUser,
                                          }
                                        : r
                                    ),
                                  }))
                                );
                              } catch (e) {
                                //console.error('[ÁÇπËµûÂõûÂ§çÈîôËØØ]', e);
                              }
                            }}
                          >
                            <Ionicons
                              name={
                                reply.liked ? 'heart' : 'heart-outline'
                              }
                              size={14}
                              color={reply.liked ? '#f33' : '#888'}
                            />
                            <Text
                              style={[
                                styles.replyLikes,
                                reply.liked && { color: '#f33' },
                              ]}
                            >
                              {reply.likes}
                            </Text>
                          </TouchableOpacity>

                          <TouchableOpacity
                            onPress={() => {
                              console.log(`[ÂõûÂ§çÂõûÂ§ç] ÂõûÂ§çÂØπË±°:`, reply);
                              handleReply(reply);
                            }}
                            style={{ marginLeft: 12 }}
                          >
                            <Ionicons
                              name="chatbubble-outline"
                              size={14}
                              color="#888"
                            />
                          </TouchableOpacity>

                          {profileData?.uuid === reply.authorUuid && (
                            <TouchableOpacity
                              onPress={() => {
                                console.log(`[Âà†Èô§ÂõûÂ§ç] ÂõûÂ§çID: ${reply.id}`);
                                handleDeleteComment(reply.id);
                              }}
                              style={{ marginLeft: 12 }}
                            >
                              <Ionicons
                                name="trash-outline"
                                size={14}
                                color="#888"
                              />
                            </TouchableOpacity>
                          )}
                        </View>
                      </View>
                      <Text style={styles.replyContent}>
                        {reply.content}
                      </Text>
                      <Text style={styles.replyTime}>
                        {reply.time}
                      </Text>
                    </View>
                  </View>
                );
              });
            })()}
          </View>
        )}
        onEndReached={loadMore}
        onEndReachedThreshold={0.5}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      />{/* Â∫ïÈÉ®Êìç‰ΩúÊ†è */}
      <View style={styles.actions}>
        <TouchableOpacity
          style={styles.commentInput}
          onPress={() => setShowCommentModal(true)}
        >
          <Ionicons name="pencil-outline" size={16} color="#888" />
          <Text style={styles.commentText}>ËØ¥ÁÇπ‰ªÄ‰πà‚Ä¶</Text>
        </TouchableOpacity>
        <View style={styles.rightActions}>
          <TouchableOpacity
            style={styles.actionItem}
            onPress={() => toggleReaction('LIKE')}
          >
            <Ionicons
              name={isLiked ? 'heart' : 'heart-outline'}
              size={22}
              color={isLiked ? '#f33' : '#888'}
            />
            <Text style={[styles.count, isLiked && { color: '#f33' }]}>
              {post.likeCount}
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.actionItem}
            onPress={() => toggleReaction('COLLECT')}
          >
            <Ionicons
              name={isCollected ? 'star' : 'star-outline'}
              size={22}
              color={isCollected ? '#fc0' : '#888'}
            />
            <Text style={[styles.count, isCollected && { color: '#fc0' }]}>
              {post.collectCount}
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.actionItem}
            onPress={scrollToComments}
          >
            <Ionicons name="chatbubble-outline" size={22} />
            <Text style={styles.count}>{post.commentCount}</Text>
          </TouchableOpacity>
        </View>
      </View>

      {/* ËØÑËÆ∫ËæìÂÖ•ÂºπÁ™ó */}
      <Modal
        visible={showCommentModal}
        transparent
        animationType="slide"
        onRequestClose={() => {
          setShowCommentModal(false);
          setReplyingTo(null);
        }}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : undefined}
          style={styles.modalContainer}
        >
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>
                {replyingTo
                  ? `ÂõûÂ§ç @${replyingTo.userName}`
                  : 'Ê∑ªÂä†ËØÑËÆ∫'}
              </Text>
              <TouchableOpacity
                onPress={() => {
                  setShowCommentModal(false);
                  setReplyingTo(null);
                }}
              >
                <Ionicons name="close" size={24} />
              </TouchableOpacity>
            </View>
            <TextInput
              style={styles.commentInputField}
              placeholder={
                replyingTo
                  ? `ÂõûÂ§ç @${replyingTo.userName}...`
                  : 'ÂÜô‰∏ã‰Ω†ÁöÑËØÑËÆ∫...'
              }
              value={commentText}
              onChangeText={setCommentText}
              multiline
              autoFocus
            />
            <TouchableOpacity
              style={[
                styles.submitButton,
                !commentText.trim() && styles.disabledButton,
              ]}
              disabled={!commentText.trim()}
              onPress={submitComment}
            >
              <Text style={styles.submitButtonText}>ÂèëÂ∏É</Text>
            </TouchableOpacity>
          </View>
        </KeyboardAvoidingView>
      </Modal>
    </View>
  );
}


